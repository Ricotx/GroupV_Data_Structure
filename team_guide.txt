# Team Implementation Guide - Data Structures Assignment

## ‚úÖ Current Foundation Status: PERFECT

### What's Ready:
- ‚úÖ **Data Models**: `Job`, `Resume`, `CustomString`, `CustomArray` in `model.hpp`
- ‚úÖ **Preprocessing**: Complete text processing in `preprocessor.hpp`
- ‚úÖ **CSV Reading**: Complete file I/O in `readcsv.hpp`
- ‚úÖ **Linked List**: Basic implementation in `linkedlist.hpp`
- ‚úÖ **Data Storage**: Templates for both teams
- ‚úÖ **Driver Program**: `main.cpp` ready for both teams

---

## Team Guidelines:

### üîó Linked List Team:

#### Phase 3 Tasks in `linkedlist_datastorage.hpp`:

**1. Add Sorting Methods (Bubble Sort):**
```cpp
void bubbleSortJobsByTitle();           // Bubble sort jobs alphabetically by title
void bubbleSortJobsBySkillCount();      // Bubble sort jobs by number of skills
void bubbleSortResumesBySkillCount();   // Bubble sort resumes by number of skills
```

**2. Add Searching Methods (Linear + Binary Search):**
```cpp
// Linear Search (works on unsorted data)
Job* linearSearchJobByTitle(const CustomString& title);
Resume* linearSearchResumeBySkill(const CustomString& skill);

// Binary Search (requires sorted data)
Job* binarySearchJobByTitle(const CustomString& title);
Job* binarySearchJobBySkillCount(int skillCount);
Resume* binarySearchResumeBySkillCount(int skillCount);
```

**3. Add Job Matching Methods (Weighted Scoring):**
```cpp
double calculateWeightedMatchScore(const Job& job, const Resume& resume);
CustomLinkedList<Job> findTopMatchesForResume(const Resume& resume, int topN);
CustomLinkedList<Resume> findTopMatchesForJob(const Job& job, int topN);
void rankMatchesByScore(CustomLinkedList<Job>& matches);
```

**4. Add Performance Testing:**
```cpp
void testSortingPerformance();
void testSearchingPerformance();
void testMatchingPerformance();
```

#### Phase 3 Tasks in `linkedlist.hpp` (if needed):
- Add `push_front()`, `insertAt()`, `deleteAt()`, `getHead()` if sorting requires them

---

### üìä Array Team:

#### Phase 3 Tasks in `array.hpp`:
**1. Complete Array Implementation:**
```cpp
template<typename T>
class CustomArrayV2 {
    // Implement all basic operations:
    void push_back(const T& item);
    T& operator[](int index);
    int size() const;
    bool empty() const;
    void clear();
    // Add sorting/searching specific methods if needed
};
```

#### Phase 3 Tasks in `array_datastorage.hpp`:
**1. Complete Data Management:**
```cpp
bool loadArrayData(const char* jobFile, const char* resumeFile);
CustomArrayV2<Job>& getJobArray();
CustomArrayV2<Resume>& getResumeArray();
void displayArrayStats();
void testArrayOperations();
```

**2. Add Same Algorithms as Linked List Team (Bubble Sort + Linear/Binary Search + Weighted Scoring):**
```cpp
// Bubble Sort (same as linked list team)
void bubbleSortJobsByTitle();           // Bubble sort jobs alphabetically by title
void bubbleSortJobsBySkillCount();      // Bubble sort jobs by number of skills
void bubbleSortResumesBySkillCount();   // Bubble sort resumes by number of skills

// Linear + Binary Search (same as linked list team)
Job* linearSearchJobByTitle(const CustomString& title);
Resume* linearSearchResumeBySkill(const CustomString& skill);
Job* binarySearchJobByTitle(const CustomString& title);
Job* binarySearchJobBySkillCount(int skillCount);
Resume* binarySearchResumeBySkillCount(int skillCount);

// Weighted Scoring Matching (same as linked list team)
double calculateWeightedMatchScore(const Job& job, const Resume& resume);
CustomArrayV2<Job> findTopMatchesForResume(const Resume& resume, int topN);
CustomArrayV2<Resume> findTopMatchesForJob(const Job& job, int topN);
void rankMatchesByScore(CustomArrayV2<Job>& matches);
```

---

## Implementation Order:

### Phase 3A: Complete Data Loading
- **Linked List Team**: ‚úÖ Already done
- **Array Team**: Complete `array_datastorage.hpp` loading methods

### Phase 3B: Implement Bubble Sort Algorithms
- **Both Teams**: Implement bubble sort for jobs and resumes
- **Compare**: Performance between linked list vs array bubble sort
- **Functions**: `bubbleSortJobsByTitle()`, `bubbleSortJobsBySkillCount()`, `bubbleSortResumesBySkillCount()`

### Phase 3C: Implement Linear + Binary Search Algorithms
- **Both Teams**: Implement linear search (unsorted) and binary search (sorted)
- **Compare**: Performance between linked list vs array searching
- **Functions**: `linearSearchJobByTitle()`, `binarySearchJobByTitle()`, `binarySearchJobBySkillCount()`

### Phase 3D: Implement Weighted Scoring Job Matching
- **Both Teams**: Implement weighted scoring matching algorithm
- **Compare**: Performance between linked list vs array matching
- **Functions**: `calculateWeightedMatchScore()`, `findTopMatchesForResume()`, `rankMatchesByScore()`

### Phase 3E: Performance Analysis
- **Both Teams**: Measure execution time and memory usage
- **Document**: Results and analysis

---

## Key Success Factors:

### 1. Identical Algorithms
- Both teams must implement the **same algorithms**
- Only difference: data structure operations (linked list vs array)

### 2. Fair Comparison
- Same data, same preprocessing, same algorithms
- Only difference: underlying data structure

### 3. Performance Testing
- Measure execution time for each operation
- Compare memory usage
- Document results

---

## File Structure for Both Teams:

```
cpp_data_structures/
‚îú‚îÄ‚îÄ linkedlist.hpp              ‚Üê Linked List Team: Basic implementation ‚úÖ
‚îú‚îÄ‚îÄ array.hpp                   ‚Üê Array Team: Complete implementation üìã
‚îú‚îÄ‚îÄ linkedlist_datastorage.hpp  ‚Üê Linked List Team: Add algorithms üìã
‚îú‚îÄ‚îÄ array_datastorage.hpp       ‚Üê Array Team: Complete + add algorithms üìã
‚îú‚îÄ‚îÄ model.hpp                   ‚Üê Shared: Data models ‚úÖ
‚îú‚îÄ‚îÄ preprocessor.hpp            ‚Üê Shared: Data preprocessing ‚úÖ
‚îú‚îÄ‚îÄ readcsv.hpp                 ‚Üê Shared: CSV reading ‚úÖ
‚îú‚îÄ‚îÄ main.cpp                    ‚Üê Shared: Driver program ‚úÖ
‚îî‚îÄ‚îÄ csv/                        ‚Üê Shared: Data files ‚úÖ
```

---

## Assignment Requirements Compliance:

### ‚úÖ Data Collection Classes
- **Linked List Team**: `CustomLinkedList<Job>`, `CustomLinkedList<Resume>`
- **Array Team**: `CustomArrayV2<Job>`, `CustomArrayV2<Resume>`

### ‚úÖ Job Matching Component
- **Both Teams**: Implement matching algorithms with justification
- **Options**: Rule-Based Matching, Weighted Scoring, Boolean Matching

### ‚úÖ Driver Program
- **Shared**: `main.cpp` tests both implementations
- **Features**: Menu interface, performance comparison, results display

### ‚úÖ Custom Data Structures
- **No STL**: Both teams use custom implementations
- **Fair Comparison**: Same algorithms, different data structures

---

## Performance Comparison Setup:

### What to Measure:
1. **Sorting Performance**: Time to sort jobs/resumes
2. **Searching Performance**: Time to find specific items
3. **Matching Performance**: Time to match jobs with resumes
4. **Memory Usage**: Memory consumption during operations

### How to Compare:
1. **Same Data**: Both teams use identical preprocessed data
2. **Same Algorithms**: Implement identical sorting/searching/matching logic
3. **Different Operations**: Linked list traversal vs array indexing
4. **Document Results**: Create performance analysis report

---

## Your Foundation is Perfect Because:

‚úÖ **Complete Infrastructure**: Both teams have everything they need
‚úÖ **Clean Separation**: No code conflicts between teams
‚úÖ **Fair Comparison**: Same data, same algorithms, different structures
‚úÖ **Assignment Compliance**: Custom data structures, no STL
‚úÖ **Professional Structure**: Clean architecture and documentation

**Both teams can now work independently on Phase 3 implementation!**

---

## Next Steps:

1. **Linked List Team**: Start implementing sorting algorithms in `linkedlist_datastorage.hpp`
2. **Array Team**: Complete `array.hpp` implementation and start algorithms
3. **Both Teams**: Implement same algorithms for fair comparison
4. **Performance Testing**: Measure and compare execution times
5. **Documentation**: Create performance analysis report

---

## ‚úÖ Algorithm Decisions Made:

### **Sorting Algorithm: Bubble Sort**
- **Both Teams**: Implement identical bubble sort algorithms
- **Functions**: `bubbleSortJobsByTitle()`, `bubbleSortJobsBySkillCount()`, `bubbleSortResumesBySkillCount()`
- **Time Complexity**: O(n¬≤)
- **Justification**: Simple to implement, easy to compare linked list vs array operations

### **Searching Algorithm: Linear + Binary Search**
- **Both Teams**: Implement identical linear and binary search algorithms
- **Linear Search**: `linearSearchJobByTitle()`, `linearSearchResumeBySkill()` (O(n), works on unsorted data)
- **Binary Search**: `binarySearchJobByTitle()`, `binarySearchJobBySkillCount()` (O(log n), requires sorted data)
- **Justification**: Shows difference between O(n) vs O(log n), demonstrates importance of sorting

### **Job Matching Algorithm: Weighted Scoring**
- **Both Teams**: Implement identical weighted scoring matching
- **Functions**: `calculateWeightedMatchScore()`, `findTopMatchesForResume()`, `rankMatchesByScore()`
- **Justification**: More sophisticated than rule-based, provides numerical scores for ranking

---

Good luck with Phase 3 implementation! üöÄ
